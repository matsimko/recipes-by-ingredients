@using System.Linq.Expressions

@inject ILogger<TagInput> _logger
@inject TagSource _tagSource

<div class="vstack gap-3">
	@for (int i = 0; i < Tags.Count; i++)
	{
		int iCopy = i;
		<div class="hstack gap-2">
			<InputText class="form-control" 
				   tabindex=@(iCopy + 1)
				   @bind-Value=Tags[iCopy].Name @oninput="(e) => HandleChange(e.Value.ToString(), iCopy)"
				   list="tagDatalist" />
			<button class="btn btn-secondary" @onclick="() => Remove(iCopy)" tabindex=@(Tags.Count + iCopy + 1)>
				<span class="oi oi-x"></span>
			</button>
		</div>
	}
</div>

<datalist id="tagDatalist">
	@foreach (var tag in _tagSuggestions)
	{
		<option>@tag.Name</option>
	}
</datalist>

@code {
	[Parameter]
	public List<TagDto> Tags { get; set; }

	private IEnumerable<TagDto> _tagSuggestions = new List<TagDto>();

	//private List<TagDto>? _tags;

	//[Parameter]
	//public List<TagDto>? Tags
	//{
	//    get => _tags;
	//    set
	//    {
	//        if (_tags == value) return;

	//        _tags = value;
	//        TagsChanged.InvokeAsync(value);
	//    }
	//}

	//[Parameter]
	//public EventCallback<List<TagDto>> TagsChanged { get; set; }

	//[Parameter]
	//public Expression<Func<List<TagDto>>>? TagsExpression { get; set; }

	private async Task HandleChange(string name, int i)
	{
		//Tags[i].Name = name; //the two-way bindings is updated only in @onchange, but I don't need to update it here
		if (i == Tags.Count - 1 && name.Length > 0)
		{
			AddTag();
		}

		if(name.Length > 2)
		{
			_tagSuggestions = await _tagSource.Search(new { prefix = name });
		}
	}

	protected override void OnInitialized()
	{
		if (Tags.Count == 0)
		{
			AddTag();
		}
	}

	private void Remove(int i)
	{
		Tags.RemoveAt(i);
		if (Tags.Count == 0)
		{
			AddTag();
		}
	}

	private void AddTag()
	{
		Tags.Add(new TagDto { Name = string.Empty });
	}
}